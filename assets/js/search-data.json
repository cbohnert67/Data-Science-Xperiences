{
  
    
        "post0": {
            "title": "Lap, can you quickly show me a long social chain?",
            "content": "The objective of the challenge: . You want to challenge your laptop. . Working with large and big integers is central to cryptography and cybersecurity applications. . You want to get a sense of feeling about working with big numbers. . You know that a very specific task in the domain, which still challenges teams of computer scientists, is to find the prime decomposition of a very big integer in a reasonable time. . This task is soundly simple in those words. . The formal question is however to find the list of prime numbers, and their multiplicity, with which such a decomposition is found. . But, you know finding big primes is practically computationally very expensive. That&#39;s interesting! . There aren&#39;t indeed very fast algorithms that can factor a, let&#39;say &#39;cryptographic number&#39;, which is a very big integer used in cybersecurity. . The overall objective of your new challenge is unique. It deserves you to bring a feel of the need of tweaking even the simplest algorithms to speed them up and solve a task. . More specifically, you want to code an efficient algorithm of prime decomposition that will push your laptop in the run. . Intrigued about that problem, you discovered some special fun integers in your discrete math textbook: . You want to exhibit the longest possible social chain with your laptop and with a minimal set of basic python tools and rules. . Let&#39;s get started! . The tools you can use and why? . You are only allowed to use the Python core library to work out arithmetic and lists operations in your code, including the modulo operation. . Especially, you constrain yourself not using any specific extra module to code your solution with, except the Datetime and Matplolib for timing considerations. . Computations are long and you guess you will need to track time and to plot some curves while investigating the complexity of the problem. . You indeed want to visualize the complexity of the solutions you find. You want to plot the time required to compute a set of inputs. . You are finally additionnaly warmly welcome to use mathematical tricks to tweak your algorithms with and to speed them up. This is an open book challenge. . How to deal with the challenge? . You are given the next three basic definitions to start with: . A perfect number $n$ is positive integer whose proper divisors (all divisors except $n$ itself) add up to $n$. | Friendly numbers is a couple $(m, n)$ of positive integers where the proper divisors of $m$ add up to $n$, and similarly, the proper divisors of $n$ add up to $m$. | A social chain is a cyclic finite sequence of $q$ positive integers $(n_1, n_2, dots, n_q$) in which one element&#39; proper divisors add up to his successor. | . This is however declarative knowledge. Although you know what these definitions mean, they don&#39;t teach you how to compute those math facts. . You therefore devise a plan for the computation. . You will start with the most basic approach: the naive approach. Listing each and every divisors of an integer. . Computing some numbers in such a way will provide a baseline for the complexity of the problem. . You next devise to code an algorithm of prime decomposition. The Sieve of Erastoten is one example. You can choose one or more examples. . Your bet is a faster running time. . After thourough thinking, you have a three steps plan which the details are given in the next sections. . A first step: getting some perfect numbers. . To tackle the first task, you have to write three utilities that do the following jobs : . A function that takes a positive integer $n$ and returns a list of all its positive divisors. | A function that takes a positive integer $n$ and returns True if $n$ is a perfect number. | A function that takes a positive integer $N$ and returns a list of all perfect numbers $n_1, n_2, dots n_q$ less than $N$. | . To that point, you will be getting a list of perfect numbers. You could therefore explore how long it takes to get a list for large $N$. . Note that in order to compute the divisors of a positive integer $n$ using a naive exhaustion approach, you will simply test each and every integers less than or equal to $n$ for divisibility. . You are furthermore suggested to keep track of the computation time to get a perfect numbers list and to study the temporal complexity this naive approach has. . You can there produce some nice visualisations to show your results. . When having an algorithm that finishes in a reasonable time and that is correct, whatever slow it is, you are ready to verify some particular perfect numbers properties. . For instance, what about the sum $S = sum_{i=1}^k frac{1}{d_i}$, where $d_i$ describes the set of all divisors of a positive integer ? . You can conjecture a result and try to prove it. . Finally in this first step, you have now tools to play with perfect numbers. Can you get a list the first ten perfect numbers in less than 30 minutes ? What is the biggest perfect number you can compute? . A second step: computing friendly numbers. . Your second task is to compute a list of friendly numbers. . You need therefore to modify your solution such that your algorithm checks whether a couple of positive integers are friendly numbers. . Recall. These numbers are defined such that the sum of the divisors of the first number is equal to the second number and vice-versa. . As in the first task, you will still use a naive solution and you will still be confronted to slow computations. . How long does it take compute the first 20 friendly numbers? . Can you produce a time complexity plot? Can you guess the Big Oh complexity of the naive solution? . The final step: tweaking your algorithm to make it faster. . Well, until now, if you wanted to compute some special numbers with a fast algorithm, you lose the challenge. . Your laptop has not enough computational power to exhibe a large perfect number or a large friendly numbers. . However, this work gives you a baseline solution that you can try to enhance. . This is your last and most important task. . Remembering the prime decomposition of a positive integer, you fortunately learn about a result that you guess will help. . The sum of every divisors of $n$, including $n$ is given by the following formula: . $$s(n)= prod_{i=1}^k frac{p_i^{ alpha_i+1}-1}{p_i-1}$$ . where $p_i$ et $ alpha_i$ are the components of the prime decomposition of $n$. This is easily checked. . Hence, instead of searching for each and every divisors of $n$ as in the naive approach, you now want to compute for the prime decomposition of that number. . That&#39;s your initial objective and you&#39;re to succeed. . As already said, there are several algorithms that tackle this problem. Choose one or two of them to implement your new solution. . Then study the time complexity of your solution. What is the longest social chain you can exhibit in 30 minutes? . What is the longest social chain you can compute patiently with your laptop? . Conclusion and take-away: . You hopefully worked out successfully the three steps of this confrontation with your laptop. . The first two tasks were not fast enough to tackle the problem of exhibing special integers large enough you can work or play with in a reasonable time... . Then you tweaked your solution using prime decompositions. This speeds up your algorithm and still you realize you are limited to relatively small numbers. . Prime decomposition is declarative knowledge, as compared to procedural knowledge. There are multitude algorithms to achieve this task. . You have now a sense of what is a hard problem. . Designing fast algorithms for prime decomposition and a various classes of problems, even resulting from soundly simple descriptions, can be very challenging and is still in active research. . As a successul Data Scientist, you have to design, optimize and work with as fast as possibe learning algorithms. .",
            "url": "https://cbohnert67.github.io/Data-Science-eXperiences/jupyter/2022/07/23/sociable-sequences.html",
            "relUrl": "/jupyter/2022/07/23/sociable-sequences.html",
            "date": " • Jul 23, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Setting Up a Data Science Environment on Linux",
            "content": "This article is a quick guide showing how to setting up a minimal Linux environment for your Data Science projects. . You should be familiar with the most usual bash commands for navigating thourgh your file structure and to install programs. . Here is what I will cover in this guide : . The terminal with zsh | The Python programming language | The conda virtual environment | th VS code editor | The Jupyter notebook | The git and Github version control | The Cookiecutter Data Science project organization | Then, I will conclude with a simple and typical workflow to follow when starting a new Data Science project. . The terminal with zsh . A terminal is used to interact with your computer via text. . The terminal we’re going to be setting up is zsh, and specifically the Oh My Zsh framework. . To install the Oh My Zsh framework, you have to first install a zsh terminal : . sudo apt install zsh . You have to exit out of your terminal and open it up again for the changes to take effect. . To verify the zsh installation, simply run : . zsh --version . Then, to install Oh My Zsh, copy-paste the command into your terminal: . sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot; . Exit out of the terminal and open it back up again. We’re done ! . The Python programming language . If you’re there you know some Python. So this part will be short. . Here, I recommend to install a new version of Python using Miniconda. . Go to the Miniconda home page and download either the “Miniconda3 Linux 64-bit” or “Miniconda3 Linux 32-bit” installer for Python 3.8. . Open up a terminal and navigate to where you downloaded the file. . Then run : . bash Miniconda3-latest-Linux-x86_64.sh . Close your terminal and re-open, then run : . conda env list . You should get a short list printed out. . Finaly, check which Python is your default : . which python . You should see a path printed out that has “miniconda” in it. We’re done ! . The conda virtual environment . A good Data Science practice is to basically separate installations of Python that have their own set of packages that they have access to. . This means each project you work on can have its own set of packages, and you don’t have to worry about your projects having conflicting package requirements. . Using conda to create a virtual environment : . Run this command to create a new conda environment named “ds-projects” with pandas installed : . conda create -n ds-projects pandas . If you run conda env list again, and you should now see “ds-projects” listed. . To Activate your conda virtual environment, simply run : . conda activate ds-projects . You are now using a new virtual environment to work in. . Hence, you can install a new package (seaborn for example) with the command : . conda install seaborn . To deactivate your conda environment : . conda deactivate . Finallly, you can remove your virtual environment by running : . conda remove --name ds-projects --all. . It’s a best practice to create a new virtual environment for each project that you work on. . th VS Code editor . The VS Code editor is popular among data scientists and developers. It has very useful functionality right out of the box with all of the features you would expect like multi-line select, an integrated terminal, and debugging tools.You can use extensions to make it as powerful as you need it to be. . Installing VS Code is very easy. Simply go to the VS Code website, click “Download”, and install using the instructions. . To use it, open up a terminal. Type : . code . . Find the “extensions” icon on the left-hand bar and click it. You should see a search bar where you can search for extensions. . Search for a Python extension (you can just search “python”), and install it. . If you’re new to VS Code, I suggest to familiarize yourself with by creating a file structure, a Hello World Python program that you will run in the integrated terminal. . The git and Github version control . A best practice is to create a new git “repository” for each project you work on. . A git repo is simply where all of your code for a project lives. . To install it, simply type : . sudo apt install git-all . Exit your terminal and open a new one. . Then, run git –version to ensure that the install worked correctly . In your terminal, run these two lines to configure your git for the first time so that git knows who you are : . git config --global user.name &quot;Your Name Here&quot; . git config --global user.email youremail@example.com . Create a project with some code to use with our first git repo. . For example, create such a file structure : . README.md . .gitignore . test_script.py . Initialize a git repo for your project, and take a snapshot (“commit”) of your code. . Run git init in your terminal to initialize a git repository in your project directory. . Run git add . in your terminal, which adds all of the files in the current directory to the “staging” area of git. . Run git commit -m “First commit.” . GitHub Usage Instructions : . Create a GitHub account. . Create a repo on GitHub. . Push your code to GitHub. . Your code and commits are now safely stored on GitHub. . The Jupyter notebook . Jupyter notebooks have become incredibly popular with data scientists over the last few years, and for good reason—they’re a great way to analyze data, run some experiments, and document your results in a way that others can follow along with. With notebooks, you create individual cells where you can either write and run Python code, or write Markdown code to document your findings. . Create a new conda environment. . In your terminal, run : . jupyter notebook . You should see some text printed to the console telling you that Jupyter notebooks is starting up and running. . Create a new notebook and play around with it. We’re almost done ! . The Cookiecutter Data Science project organization . Cookiecutter Data Science is essentially a template project directory that you can use when you start new data science projects. . A good suggestion for starting out is to just use the main directories that scripts that you need. . A good starting place is to only use the “data”, “notebooks”, and “src” folders. . To install via conda, run this command in your terminal : . conda install -c conda-forge cookiecutter . Use cookiecutter to download and create a data science project template : . cookiecutter https://github.com/drivendata/cookiecutter-data-science . Delete anything you don’t want. . A typical workflow for a Data Science project . Open up your terminal. . Create a new conda environment for your project : . conda create -n my-project-env pandas jupyter scikit-learn matplotlib seaborn . conda activate my-project-env . Create a new project directory using cookiecutter : . cookiecutter https://github.com/drivendata/cookiecutter-data-science . Open up your new project directory in VS Code : . code my-project-directory . Open up a terminal in VS Code, initialize a new git repo, and take a first snapshot. . git init . git add . . git commit -m “First commit.” . Create a new repo on GitHub, then follow the instructions to push your code from your computer project directory to that repo : . git remote add origin https://www.github.com/yourname/your-repo-name.git . git push origin master . And now you’re ready to go for your next data science project. . Happy coding ! .",
            "url": "https://cbohnert67.github.io/Data-Science-eXperiences/markdown/2021/12/08/Setting-up-a-data-science-environment-on-Linux.html",
            "relUrl": "/markdown/2021/12/08/Setting-up-a-data-science-environment-on-Linux.html",
            "date": " • Dec 8, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Décomposition de Zeckendorf et jeu de Nim",
            "content": "La d&#233;composition de Zeckendorf . Si $n$ est un entier naturel, alors il existe une unique représentation de Zeckendorf de $n$. . Cette décomposition est la liste des uniques nombres de Fibonacci deux à deux distincts et non consécutifs de somme égale à $n$. . Impl&#233;mentation . def getNearestFibonacciNumber(n): &quot;&quot;&quot;Returns the greatest Fibonacci Number smaller than or equal to n.&quot;&quot;&quot; if (n == 0 or n == 1): return n f1, f2, f3 = 0, 1, 1 while (f3 &lt;= n): f1 = f2 f2 = f3 f3 = f1 + f2 return f2 def getZeckendorf(n): &quot;&quot;&quot;Returns the Zeckendorf decomposition of n.&quot;&quot;&quot; zeckendorf = [] while (n&gt;0): f = getNearestFibonacciNumber(n); zeckendorf.append(f) n = n-f return zeckendorf . zeckendorf = getZeckendorf(64) . zeckendorf . [55, 8, 1] . On vérifie bien : . sum(zeckendorf) . 64 . Application au jeu de Nim . Deux joueurs tirent à leur tour des allumettes d&#39;une boîte, avec les règles suivantes : . Chaque joueur tire à chaque fois au moins une allumette | Le premier joueur ne retire pas la totalité des allumettes au premier tour | Un joueur tire au plus deux fois le nombre d&#39;allumettes tirées par le joueur précédent | Le joueur qui retire la dernière allumette a gagné | . On peut montrer que si le nombre initial d&#39;allumettes n&#39;est pas un nombre de Fibonacci, une stratégie gagnante pour le joueur 1 consiste à tirer autant d&#39;allumettes que le plus petit terme de la décomposition de Zeckendorf du nombre d&#39;allumettes. . def playNim(n): &quot;&quot;&quot; Runs a game of Nim against computer with n not being a Fibonacci number&quot;&quot;&quot; tour = 0 joueur = 0 while True: tour += 1 tirage = getZeckendorf(n)[-1] print(&quot;Tour {} :&quot;.format(tour)) print(&quot;Joueur 1 : {} allumettes restantes.&quot;.format(n)) print(&quot;Ordinateur tire {} allumettes&quot;.format(tirage)) n -= tirage if n==0: print(&quot;Ordinateur a gagné!&quot;) break print(&quot;Joueur 2 : {} allumettes restantes.&quot;.format(n)) n -= int(input(&quot;Tirer entre 1 et {} allumettes : &quot;.format(2*tirage))) if n==0: print(&quot;Vous avez gagné!&quot;) break . playNim(60) . Tour 1 : Joueur 1 : 60 allumettes restantes. Ordinateur tire 5 allumettes Joueur 2 : 55 allumettes restantes. Tirer entre 1 et 10 allumettes : 1 Tour 2 : Joueur 1 : 54 allumettes restantes. Ordinateur tire 2 allumettes Joueur 2 : 52 allumettes restantes. Tirer entre 1 et 4 allumettes : 4 Tour 3 : Joueur 1 : 48 allumettes restantes. Ordinateur tire 1 allumettes Joueur 2 : 47 allumettes restantes. Tirer entre 1 et 2 allumettes : 1 Tour 4 : Joueur 1 : 46 allumettes restantes. Ordinateur tire 1 allumettes Joueur 2 : 45 allumettes restantes. Tirer entre 1 et 2 allumettes : 1 Tour 5 : Joueur 1 : 44 allumettes restantes. Ordinateur tire 2 allumettes Joueur 2 : 42 allumettes restantes. Tirer entre 1 et 4 allumettes : 1 Tour 6 : Joueur 1 : 41 allumettes restantes. Ordinateur tire 2 allumettes Joueur 2 : 39 allumettes restantes. Tirer entre 1 et 4 allumettes : 1 Tour 7 : Joueur 1 : 38 allumettes restantes. Ordinateur tire 1 allumettes Joueur 2 : 37 allumettes restantes. Tirer entre 1 et 2 allumettes : 1 Tour 8 : Joueur 1 : 36 allumettes restantes. Ordinateur tire 2 allumettes Joueur 2 : 34 allumettes restantes. Tirer entre 1 et 4 allumettes : 1 Tour 9 : Joueur 1 : 33 allumettes restantes. Ordinateur tire 1 allumettes Joueur 2 : 32 allumettes restantes. Tirer entre 1 et 2 allumettes : 2 Tour 10 : Joueur 1 : 30 allumettes restantes. Ordinateur tire 1 allumettes Joueur 2 : 29 allumettes restantes. Tirer entre 1 et 2 allumettes : 2 Tour 11 : Joueur 1 : 27 allumettes restantes. Ordinateur tire 1 allumettes Joueur 2 : 26 allumettes restantes. Tirer entre 1 et 2 allumettes : 2 Tour 12 : Joueur 1 : 24 allumettes restantes. Ordinateur tire 3 allumettes Joueur 2 : 21 allumettes restantes. Tirer entre 1 et 6 allumettes : 6 Tour 13 : Joueur 1 : 15 allumettes restantes. Ordinateur tire 2 allumettes Joueur 2 : 13 allumettes restantes. Tirer entre 1 et 4 allumettes : 1 Tour 14 : Joueur 1 : 12 allumettes restantes. Ordinateur tire 1 allumettes Joueur 2 : 11 allumettes restantes. Tirer entre 1 et 2 allumettes : 1 Tour 15 : Joueur 1 : 10 allumettes restantes. Ordinateur tire 2 allumettes Joueur 2 : 8 allumettes restantes. Tirer entre 1 et 4 allumettes : 1 Tour 16 : Joueur 1 : 7 allumettes restantes. Ordinateur tire 2 allumettes Joueur 2 : 5 allumettes restantes. Tirer entre 1 et 4 allumettes : 1 Tour 17 : Joueur 1 : 4 allumettes restantes. Ordinateur tire 1 allumettes Joueur 2 : 3 allumettes restantes. Tirer entre 1 et 2 allumettes : 2 Tour 18 : Joueur 1 : 1 allumettes restantes. Ordinateur tire 1 allumettes Ordinateur a gagné! .",
            "url": "https://cbohnert67.github.io/Data-Science-eXperiences/jupyter/2021/12/01/Zeckendorf-et-jeu-du-nim.html",
            "relUrl": "/jupyter/2021/12/01/Zeckendorf-et-jeu-du-nim.html",
            "date": " • Dec 1, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://cbohnert67.github.io/Data-Science-eXperiences/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://cbohnert67.github.io/Data-Science-eXperiences/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About",
          "content": "Cédric Bohnert, Strasbourg, France. .",
          "url": "https://cbohnert67.github.io/Data-Science-eXperiences/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://cbohnert67.github.io/Data-Science-eXperiences/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}